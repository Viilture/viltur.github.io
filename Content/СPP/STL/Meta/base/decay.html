<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Viilture</title>
    <!-- Подключение внешнего CSS для фона -->
    <link rel="stylesheet" href="https://viilture.github.io/viltur.github.io/background/background.css">

</head>
<body style="font-family: Arial, sans-serif; margin: 0; padding: 0; background-color: #2C3E50; color: #ecf0f1;">
            <div class="navbar">
                <a href="https://viilture.github.io/viltur.github.io/">Главная</a>
                <a href="#about">Linux</a>
                <a href="https://viilture.github.io/viltur.github.io/Content/Literature/LiteratureMain.html">Литература</a>
                <a href="https://viilture.github.io/viltur.github.io/Content/СPP/СPPMain.html">С++</a>
                <a href="https://viilture.github.io/viltur.github.io/Content/Instructions/Instructions.html">Инструкции</a>
            </div>
        
            <main style="padding: 50px 20px;">
                <section style="max-width: 800px; margin: auto; background-color: #34495e; padding: 20px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);">
                    <h2>Что такое <code>std::decay</code>?</h2>
                    <p>
                        <code>std::decay</code> — это метафункция из стандартной библиотеки C++, которая преобразует тип, удаляя ссылки,
                        константные и волатильные квалификаторы, а также заменяя массивы и функции на указатели. Это особенно полезно при работе с шаблонами.
                    </p>
                </section>
        
                <section style="max-width: 800px; margin: 40px auto; background-color: #34495e; padding: 20px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);">
                    <h2>Пример использования</h2>
                    <pre style="background-color: #2c3e50; color: #ecf0f1; padding: 15px; border-radius: 5px; overflow-x: auto;">
        <code>
        #include &lt;iostream&gt;
        #include &lt;type_traits&gt;
        
        template &lt;typename T&gt;
        void displayType() {
            using DecayedType = typename std::decay&lt;T&gt;::type;
            std::cout &lt;&lt; "Decayed type: " &lt;&lt; typeid(DecayedType).name() &lt;&lt; std::endl;
        }
        
        int main() {
            int arr[5];
            displayType&lt;decltype(arr)&gt;(); // Вывод: Decayed type: Pi
        
            const double& ref = 3.14;
            displayType&lt;decltype(ref)&gt;(); // Вывод: Decayed type: d
        
            return 0;
        }
        </code>
                    </pre>
                </section>
        
                <section style="max-width: 800px; margin: 40px auto; background-color: #34495e; padding: 20px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);">
                    <h2>Когда использовать <code>std::decay</code>?</h2>
    <p>
        Применяйте <code>std::decay</code> в шаблонных функциях и классах, чтобы обеспечить получение "чистого" типа параметра. 
        Это помогает избежать неожиданных поведений при передаче аргументов по ссылке или константности. Рассмотрим подробнее, 
        как и почему используется <code>std::decay</code>.
    </p>

    <h3>Глубокое описание работы <code>std::decay</code></h3>
    <p>
        <code>std::decay</code> — это метафункция из заголовочного файла <code>&lt;type_traits&gt;</code>, которая применяется к типу 
        и производит ряд преобразований:
    </p>
    <ul>
        <li>Удаляет ссылки (как lvalue, так и rvalue).</li>
        <li>Удаляет квалификаторы <code>const</code> и <code>volatile</code>.</li>
        <li>Преобразует массивы в указатели.</li>
        <li>Преобразует функции в указатели на функции.</li>
    </ul>
    <p>
        Это поведение аналогично механизму передачи аргументов по значению в C++. Использование <code>std::decay</code> гарантирует, 
        что тип параметра будет "очищен" от ссылок и квалификаторов, что особенно полезно при работе с шаблонами.
    </p>

    <h3>Примеры использования <code>std::decay</code></h3>

    <h4>Пример 1: Очистка типа аргумента</h4>
    <p>
        Рассмотрим функцию-шаблон, которая принимает аргумент по универсальной ссылке. Используя <code>std::decay</code>, 
        мы можем получить "чистый" тип аргумента.
    </p>
    <pre>
<code class="language-cpp">
#include &lt;iostream&gt;
#include &lt;type_traits&gt;
#include &lt;typeinfo&gt;

template &lt;typename T&gt;
void displayDecayedType(T&& param) {
    using DecayedType = typename std::decay&lt;T&gt;::type;
    std::cout &lt;&lt; "Original type: " &lt;&lt; typeid(T).name() &lt;&lt; std::endl;
    std::cout &lt;&lt; "Decayed type: " &lt;&lt; typeid(DecayedType).name() &lt;&lt; std::endl;
}

int main() {
    int a = 10;
    const double& b = 3.14;
    int arr[5];

    displayDecayedType(a);       // T = int
    displayDecayedType(b);       // T = const double&
    displayDecayedType(arr);     // T = int[5]

    return 0;
}
</code>
    </pre>
    <p>Вывод программы:</p>
    <pre>
Original type: i
Decayed type: i
Original type: RKd
Decayed type: d
Original type: A5_i
Decayed type: Pi
    </pre>
    <p>
        В этом примере:
    </p>
    <ul>
        <li><code>int a</code> остается <code>int</code> после декейдирования.</li>
        <li><code>const double& b</code> преобразуется в <code>double</code>.</li>
        <li><code>int arr[5]</code> преобразуется в <code>int*</code>.</li>
    </ul>

    <h4>Пример 2: Использование <code>std::decay</code> в шаблонизации функций</h4>
    <p>
        При создании оберток для функций, таких как функциональные объекты или делегаты, часто требуется декейдировать типы аргументов.
    </p>
    <pre>
<code class="language-cpp">
#include &lt;iostream&gt;
#include &lt;functional&gt;
#include &lt;type_traits&gt;

template &lt;typename Func, typename... Args&gt;
auto make_callable(Func&& func, Args&&... args)
    -&gt; std::function&lt;typename std::decay&lt;Func&gt;::type(typename std::decay&lt;Args&gt;::type...)&gt; {
    using DecayedFunc = typename std::decay&lt;Func&gt;::type;
    using CallableType = typename std::decay&lt;Func&gt;::type(typename std::decay&lt;Args&gt;::type...);
    return std::function&lt;CallableType&gt;(std::forward&lt;Func&gt;(func));
}

int main() {
    auto lambda = [](int x) { return x * x; };
    auto callable = make_callable(lambda);

    std::cout &lt;&lt; "Callable result: " &lt;&lt; callable(5) &lt;&lt; std::endl; // Вывод: 25

    return 0;
}
</code>
    </pre>
    <p>
        В этом примере функция <code>make_callable</code> принимает любую вызываемую сущность и аргументы, декейдирует их типы и  оборачивает их в <code>std::function</code>. Это обеспечивает гибкость и безопасность типов при работе с шаблонами.
    </p>

    <h3>Глубокое понимание работы <code>std::decay</code></h3>
    <p>
        Чтобы глубже понять, как работает <code>std::decay</code>, рассмотрим его внутреннюю реализацию. В стандартной библиотеке 
        <code>std::decay</code> определен следующим образом:
    </p>
    <pre>
<code class="language-cpp">
template &lt;typename T&gt;
struct decay {
private:
    typedef typename std::remove_reference&lt;T&gt;::type U;
public:
    typedef typename std::conditional&lt;
        std::is_array&lt;U&gt;::value,
        typename std::remove_extent&lt;U&gt;::type*,
        typename std::conditional&lt;
            std::is_function&lt;U&gt;::value,
            typename std::add_pointer&lt;U&gt;::type,
            typename std::remove_cv&lt;U&gt;::type
        &gt;::type
    &gt;::type type;
};
</code>
    </pre>
    <p>
        Этот шаблонный класс последовательно применяет следующие преобразования:
    </p>
    <ol>
        <li>Удаляет ссылку с помощью <code>std::remove_reference</code>.</li>
        <li>Проверяет, является ли тип массивом или функцией:
            <ul>
                <li>Если массивом, то преобразует его в указатель на первый элемент.</li>
                <li>Если функцией, то преобразует в указатель на функцию.</li>
            </ul>
        </li>
        <li>В противном случае удаляет квалификаторы <code>const</code> и <code>volatile</code> с помощью <code>std::remove_cv</code>.</li>
    </ol>

    <h3>Расширенные примеры</h3>
    <section>
    <h4>Пример 3: Использование <code>std::decay</code> с функциями-членами и классами</h4>
    <p>
        При работе с функциями-членами классов или методами, <code>std::decay</code> помогает получить тип, пригодный для хранения или передачи.
    </p>
    <pre>
<code class="language-cpp">
#include &lt;iostream&gt;
#include &lt;type_traits&gt;
#include &lt;functional&gt;

struct MyClass {
    void memberFunction(int x) const {
        std::cout &lt;&lt; "Member function called with: " &lt;&lt; x &lt;&lt; std::endl;
    }
};

int main() {
    MyClass obj;
    auto boundFunc = std::bind(&MyClass::memberFunction, obj, std::placeholders::_1);

    using DecayedType = typename std::decay&lt;decltype(boundFunc)&gt;::type;
    static_assert(std::is_same&lt;DecayedType, std::function&lt;void(int)&gt;&gt;::value, "Types do not match");

    boundFunc(42); // Вывод: Member function called with: 42

    return 0;
}
</code>
    </pre>
    <p>
        В этом примере мы используем <code>std::bind</code> для связывания функции-члена с объектом. Затем, используя 
        <code>std::decay</code>, мы декейдим тип связанной функции, чтобы получить тип <code>std::function&lt;void(int)&gt;</code>.
    </p>

    <h3>Полезные ссылки и источники</h3>
    <ul>
        <li>
            <a href="https://en.cppreference.com/w/cpp/types/decay" target="_blank" rel="noopener noreferrer">
                std::decay на cppreference.com
            </a>
        </li>
        <li>
            <a href="https://www.cppstories.com/2020/stddecay/" target="_blank" rel="noopener noreferrer">
                Понимание std::decay и его использования в C++
            </a>
        </li>
        <li>
            <a href="https://isocpp.org/wiki/faq/templates#perfect-forwarding" target="_blank" rel="noopener noreferrer">
                Совершенная передача (Perfect Forwarding) в C++ на isocpp.org
            </a>
        </li>
        <li>
            <a href="https://www.modernescpp.com/index.php/move-semantics-and-perfect-forwarding" target="_blank" rel="noopener noreferrer">
                Семантика перемещения и совершенная передача на Modern C++
            </a>
        </li>
        <li>
            <a href="https://stackoverflow.com/questions/19866546/what-is-stddecay" target="_blank" rel="noopener noreferrer">
                Объяснение std::decay на Stack Overflow
            </a>
        </li>
    </ul>

    <h3>Заключение</h3>
    <p>  Использование <code>std::decay</code> является важной практикой при работе с шаблонами в C++. Оно обеспечивает гибкость и 
        корректность типов, устраняя потенциальные проблемы, связанные с ссылками и квалификаторами. Глубокое понимание работы 
        <code>std::decay</code> помогает создавать более надежные и эффективные обобщенные компоненты.
    </p>
</section>
        </body>

</html>

