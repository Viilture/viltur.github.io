<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Мой сайт с красивым анимированным космосом и Фиксированным Оглавлением</title>
    <!-- Подключение внешнего CSS для фона -->
    <link rel="stylesheet" href="https://viilture.github.io/viltur.github.io/background/background.css">

</head>
<body>

    <div class="navbar">
        <a href="https://viilture.github.io/viltur.github.io/">Главная</a>
        <a href="#about">Linux</a>
        <a href="https://viilture.github.io/viltur.github.io/Content/Literature/LiteratureMain.html">Литература</a>
        <a href="https://viilture.github.io/viltur.github.io/Content/CPP/CPPMain.html">С++</a>
    </div>
    


    <!-- Фиксированное Оглавление -->
    <div class="sidebar">
        <h2>Оглавление</h2>
        <ul>
            <li><a href="#chapter1">Ядро Linux</a></li>
            <li><a href="#chapter2">Глава 1. Понятие о ядре Linux</a></li>
            <li><a href="#chapter3">Глава 2. Начальные сведения о ядре Linux</a></li>
            <li><a href="#chapter4">Глава 3. Управление процессами</a></li>
            <li><a href="#chapter5">Глава 4. Системный планировщик и диспетчеризация процессов</a></li>
            <li><a href="#chapter6">Глава 5. Системные функции</a></li>
            <li><a href="#chapter7">Глава 6. Структуры данных ядра</a></li>
            <li><a href="#chapter8">Глава 7. Прерывания и их обработка</a></li>
            <li><a href="#chapter9">Глава 8. Нижняя половина обработчика и отложенные действия</a></li>
            <li><a href="#chapter10">Глава 9. Общие сведения о синхронизации кода ядра</a></li>
            <li><a href="#chapter11">Глава 10. Средства синхронизации ядра</a></li>
            <li><a href="#chapter12">Глава 11. Таймеры и управление временем</a></li>
            <li><a href="#chapter13">Глава 12. Управление памятью</a></li>
            <li><a href="#chapter14">Глава 13. Виртуальная файловая система</a></li>
            <li><a href="#chapter15">Глава 14. Уровень блочного ввода-вывода</a></li>
            <li><a href="#chapter16">Глава 15. Адресное пространство процесса</a></li>
            <li><a href="#chapter17">Глава 16. Страничный кеш и отложенная запись страниц</a></li>
            <li><a href="#chapter18">Глава 17. Устройства и модули</a></li>
            <li><a href="#chapter19">Глава 18. Отладка</a></li>
            <li><a href="#chapter20">Глава 19. Переносимость</a></li>
            <li><a href="#chapter21">Глава 20. Заплаты, хакерство и сообщество</a></li>
            <li><a href="#chapter22">Список литературы</a></li>



            <!-- Добавьте дополнительные главы по необходимости -->
        </ul>
    </div>

    <!-- Основное Содержимое -->
    <div class="main-content" id="home">


        <!-- Главы Книги -->
        <div class="chapter" id="chapter1">
            <h3>Ядро Linux Описание</h3>
            <p>
                Исчерпывающее руководство по проектированию и реализации ядра Linux. В этой книге описаны основные принципы проектирования и детали реализации ядра Linux. Материал представлен в форме, удобной как для тех, кто занимается разработкой кода ядра, так и для программистов, которые хотят лучше понять особенности работы операционных систем и соответственно разрабатывать более эффективные прикладные программы. В книге детально рассмотрены основные подсистемы и функции ядра Linux, особенности их построения, реализации и соответствующие программные интерфейсы. При этом ядро рассматривается под разными углами: теоретическим и прикладным, что может привлечь читателей с различными интересами и запросами.</p>
        </div>

        <div class="chapter" id="chapter2">
            <h3>Глава 1. Понятие о ядре Linux</h3>
            <p>
                 Эта книга посвящена ядру Linux и целям, поставленным перед разработчиками, проектным решениям, которые были направлены на достижение этих целей, и реализациям, которые позволят осуществить эти проектные решения. В книге описаны практические вопросы. При объяснении сложных понятий как и что работает в ней используется подход на основании золотой середины между теорией и практикой. Моя цель — дать читателю информацию из первых рук и помочь разобраться в проектных решениях и реализациях, положенных в основу ядра Linux. Такой интересный подход в сочетании с личным практическим опытом автора и советами по хакерским приемам позволяет быть уверенным в том, что книга станет хорошим подручным средством для тех, кто собирается разрабатывать код ядра, новый драйвер устройства или просто хочет лучше понять принципы работы ОС Linux. Во время чтения книги у вас должен быть доступ к системе Linux и исходным кодам ее ядра. В идеале предполагается, что читатель — пользователь операционной системы Linux, который уже “копался” в исходном программном коде, но все же нуждается в некоторой помощи для того, чтобы все связать воедино. В принципе, читатель может и не быть пользователем Linux, но хочет разобраться в устройстве ядра из чистого любопытства. Тем не менее, для того чтобы самому научиться писать программы — исходный код незаменим. Исходный программный код свободно доступен — пользуйтесь им!    </p>
        </div>

        <div class="chapter" id="chapter3">
            <h3>Глава 2. Начальные сведения о ядре Linux</h3>
            <p>
            Как вы уже поняли, ядро Linux обладает уникальными качествами. В нем принят ряд особых правил и исключений, которые являются очень важными и влияют на работу всей системы. Выше мы уже говорили, что сложность кода ядра и необходимый уровень подготовки программистов для его разработки принципиально ничем не отличаются от любого другого большого программного проекта. Самым важным шагом на пути к разработке ядра Linux является осознание того, что ядро не так уж и страшно, как оно кажется на первый взгляд. Незнакомо? Конечно! Непреодолимо? Не для всех! Вводный материал, который был представлен в первой главе, и базовые моменты, описанные в текущей, надеюсь, станут хорошим фундаментом для тех знаний, которые будут получены при прочтении всей книги. В каждой из последующих глав будут описаны конкретные подсистемы ядра и принципы их работы. Помимо всего прочего, очень важно, чтобы вы самостоятельно смогли разобраться в исходном коде ядра и внести в него изменения. Только в процессе реального знакомства с исходным кодом и выполнения экспериментов с ним вы сможете все понять. В конце концов

           ​  </p>
        </div>

        <div class="chapter" id="chapter4">
            <h3>Глава 3. Управление процессами</h3>
            <p>
               В этой главе была рассмотрена очень важная абстракция операционной системы, которая называется процессом, описаны общие свойства процессов и их назначение, а также представлено сравнение процессов и потоков. Кроме того, было описано, как операционная система Linux хранит и представляет информацию, которая относится к процессам (структуры task_struct и thread_info), как создаются процессы (через вызовы системных функций fork() и в конечном итоге clone()), каким образом новые исполняемые образы загружаются в адресное пространство (через семейство системных функций exec()). Мы рассмотрели иерархию процессов, описали, как родительский процесс получает информацию о своих завершившихся дочерних процессах (семейство системных функций wait()) и как в конце концов процесс завершается (непреднамеренно или с помощью вызова системной функции exit()). Процесс — это основополагающая и ключевая абстракция, которая используется во всех современных операционных системах и в конечном итоге является тем, ради чего вообще создаются операционные системы (т.е. для запуска пользовательских программ). Следующая глава посвящена планированию процессов — чрезвычайно интересной и деликатной теме. Вы узнаете, как планировщик ядра решает, какой именно процесс нужно запустить, в какой момент времени и в каком порядке.  </p>
         </p>
        </div>

        <div class="chapter" id="chapter5">
            <h3>Глава 4. Системный планировщик и диспетчеризация процессов</h3>
            <p>
              Системный планировщик является важным компонентом ядра любой операционной системы, поскольку в запуске процессов состоит основной смысл использования компьютера (по крайней мере, для большинства из нас!). Однако удовлетворение всех требований, предъявляемых к планировщику, — очень не простая задача. Большое количество выполняемых процессов, требования масштабируемости, компромисс между производительностью и временем реакции, а также требования для различных типов загрузки системы приводят к тому, что тяжело найти алгоритм, который подходит для всех случаев. Несмотря на это, новый системный планировщик CFS ядра Linux приближается к тому, чтобы удовлетворить всем этим требованиям и обеспечить оптимальное решение для всех случаев, включая отличную масштабируемость и привлекательную реализацию. В предыдущей главе мы рассмотрели средства управления процессами. В этой главе была описана теория планирования процессов и ее специфические реализации, алгоритмы и интерфейсы, используемые в текущей версии ядра Linux. В следующей главе будет рассмотрен основной интерфейс, который предоставляет ядро выполняющимся процессам. Речь пойдет о системных функциях.  </p>
         </p>
        </div>

        <div class="chapter" id="chapter6">
            <h3>Глава 5. Системные функции</h3>
            <p>
            В этой главе было рассмотрено, что такое системные функции и чем они отличаются от библиотечных функций и интерфейса прикладных программ (API). Затем мы рассмотрели процесс реализации системной функции в ядре и цепочку событий, которая происходит при ее вызове: переход в ядро, передача номера функции и всех необходимых параметров соответствующей функции ядра и ее выполнение, возврат результатов работы в пользовательское приложение. Далее рассказывалось, как добавить новую системную функцию в ядро, и был приведен простой пример вызова системной функции из пользовательского приложения. Весь процесс является достаточно простым! Поскольку добавить новую системную функцию довольно просто, основная работа заключается в ее реализации. В оставшейся части книги рассмотрены основные принципы, а также интерфейсы, которые необходимо использовать при создании хорошо работающих, оптимальных и безопасных системных функций. В конце главы были рассмотрены некоторые преимущества и недостатки, возникающие при реализации системных функций, и представлен краткий список возможных вариантов, позволяющих избежать добавления новых системных функций.

           ​       </p>
        </div>

        <div class="chapter" id="chapter7">
            <h3>Глава 6. Структуры данных ядра</h3>
            <p>
               В этой главе мы рассмотрели довольно много обобщенных структур данных, которые используются разработчиками ядра Linux для реализации нужной функциональности, начиная с системного планировщика и заканчивая драйверами устройств. По мере того как мы будем продвигаться вглубь в изучении ядра Linux, материал этой главы вам будет полезен не раз. При написании собственного кода ядра всегда старайтесь использовать готовую инфраструктуру и не пытайтесь изобретать велосипед! В этой главе мы также ознакомились с понятием алгоритмической сложности и средствами, с помощью которых ее можно оценить и выразить. Самым значимым из них является понятие большого “O”. На протяжении всей книги, а также в ядре Linux мы будем опираться на него при анализе того, насколько хорошо выбранные алгоритмы и компоненты ядра масштабируются в свете большого числа пользователей, процессов, процессоров, сетевых соединений и других постоянно растущих исходных данных.   </p>
        </div>

        <div class="chapter" id="chapter8">
            <h3>Глава 7. Прерывания и их обработка</h3>
            <p>
                В этой главе были рассмотрены прерывания, а также аппаратные ресурсы, которые используются устройствами для подачи асинхронных сигналов процессору. По сути, прерывания используются аппаратным обеспечением, чтобы прервать работу операционной системы. В большинстве современных устройств прерывания используются в качестве механизма взаимодействия устройства с операционной системой. Драйвер устройства, который управляет некоторым оборудованием, должен зарегистрировать обработчик прерывания, чтобы отвечать на эти прерывания и обрабатывать их. В обработчике прерывания устройству отправляется подтверждение о получении прерывания, выполняется инициализация оборудования, копирование данных из памяти устройства в память системы и, наоборот, обработка аппаратных запросов и отправка ответов на них. В ядре предусмотрен ряд интерфейсов для регистрации и удаления обработчиков прерываний, запрещения прерываний, маскирования линий IRQ и проверки состояния системы прерываний. В табл. 7.2 приведен обзор некоторых из этих функций. Поскольку прерывания прерывают выполнение другого кода (кода процессов, кода ядра и даже кода других обработчиков прерываний), их обработчики должны выполняться максимально быстро. Тем не менее в обработчике прерывания часто приходится выполнять много работы. Для достижения компромисса между большим количеством работы и необходимостью быстрого выполнения обработка прерывания делится на две половины. Собственно обработчик прерывания, рассмотренный в этой главе, относится к верхней половине. В следующей главе мы рассмотрим нижнюю половину процесса обработки прерывания.  </p>
        </div>

        <div class="chapter" id="chapter9">
            <h3>Глава 8. Нижняя половина обработчика и отложенные действия</h3>
            <p>
            В этой главе были рассмотрены три механизма, которые используются для реализации отложенных действий в ядре Linux, — отложенные прерывания (softirq), тасклеты (tasklet) и очереди отложенных действий (work queue). Было показано, как работают и реализованы эти механизмы. Также обсуждались основные моменты, связанные с использованием этих механизмов в собственном программном коде, и отмечалось, что их названия выбраны неудачно. Для того чтобы восстановить историческую справедливость, мы также рассмотрели те механизмы нижних половин обработчиков прерываний, которые существовали в предыдущих версиях ядра Linux: BH и очередь задач. Очень часто в настоящей главе поднимались вопросы синхронизации и параллельного выполнения кода, поскольку они имеют прямое отношение к нижним половинам обработчиков. В главу специально был включен раздел, посвященный запрещению обработки нижних половин, в котором шла речь о защите совместно используемых данных от конкурентного доступа. Теперь пришло время погрузиться в эти темы с головой. В главе 9, “Общие сведения о синхронизации кода ядра”, будут рассмотрены особенности синхронизации и параллельного выполнения кода в ядре. Этот материал позволит вам изучить основы и понять основные проблемы, которые часто приходится устранять. В главе 10, “Средства синхронизации ядра”, будут рассмотрены интерфейсы, позволяющие осуществлять синхронизацию в ядре и решать указанные проблемы. Вооружившись материалов следующих двух глав, вы сможете покорить мир!

           ​ </p>
        </div>

        <div class="chapter" id="chapter10">
            <h3>Глава 9.Общие сведения о синхронизации кода ядра</h3>
            <p>
               Разработку кода, устойчивого к симметричной обработке, нельзя откладывать на потом. Правильная синхронизация, система блокировок без возникновения тупиковых ситуаций, масштабируемость и ясность кода — все эти факторы следует учитывать при разработке с самого начала и до самого конца. При написании кода ядра, будь то новая системная функция или модификация драйвера устройства, необходимо прежде всего позаботиться об обеспечении защиты данных от конкурентного доступа. Обеспечение достаточной защиты для любого возможного случая, как-то использование симметричной многопроцессорной обработки, мультипрограммный режим работы ядра и тому подобное, приведет к тому, что все данные будут надежно защищены на любой машине и при любой конфигурации. В следующей главе речь пойдет о том, как это осуществить. После изучения основ и теории синхронизации, параллельной обработки и блокировок пора перейти к рассмотрению конкретных средств, предусмотренных в ядре Linux для устранения конфликтов при доступе к ресурсам и взаимоблокировок в коде.  </p>
        </div>

        <div class="chapter" id="chapter11">
            <h3>Глава 10.Средства синхронизации ядра</h3>
            <p>
               В этой главе рассказывалось о том, как применять на практике понятия, описанные в предыдущей главе, чтобы лучше разобраться с функциями ядра, которые помогают осуществлять синхронное и параллельное выполнение операций. Вначале были рассмотрены самые простые методы, обеспечивающие синхронизацию выполнения, — неделимые операции. Далее были описаны спин-блокировки — часто используемые типы блокировок в ядре. Они построены на основе периодической проверки в цикле условия освобождения блокировки и позволяют гарантировать, что доступ к ресурсу получит только один поток выполнения. После этого были рассмотрены семафоры — блокировки, которые переводят вызывающий процесс в состояние ожидания, а также их более специализированные и чаще используемые типы — мьютексы. Следом за мьютексами были описаны более специфические (и менее используемые) типы блокировок, такие как условные переменные и последовательные блокировки. Мы в шутливом тоне описали большую блокировку ядра BKL, рассмотрели методы запрещения режима вытеснения кода ядра и коснулись барьеров. Спектр информации был очень большой. Вооружившись арсеналом средств синхронизации, описанных в данной главе, вы сможете писать код ядра, свободный от конфликтов из-за использования ресурсов, обеспечивающий необходимую синхронизацию с помощью самого подходящего для этого инструментария и корректно работающий на машинах с несколькими процессорами.  </p>
        </div>

        <div class="chapter" id="chapter12">
            <h3>Глава 11.Таймеры и управление временем</h3>
            <p>
                В этой главе были рассмотрены понятия, связанные с представлением времени в ядре, а также способы отслеживания абсолютного и относительного хода времени. Были показаны отличия абсолютного и относительного времени, а также периодических и разовых событий. Далее были рассмотрены прерывания от таймера, представление времени в количестве импульсов таймера, константа HZ и переменная jiffies. Затем речь шла о том, как реализованы таймеры ядра и как их можно использовать в собственном коде ядра. В конце главы были представлены другие методы, которые разработчики могут использовать для реализации временных задержек. При написании большей части кода ядра вам потребуются знания о представлении времени в ядре и его отслеживании. С очень большой вероятностью, особенно при разработке драйверов, вы столкнетесь с таймерами ядра. Материал этой главы принесет вам практическую пользу и не будет простой тратой времени. </p>
        </div>

        <div class="chapter" id="chapter13">
            <h3>Глава 12. Управление памятью</h3>
            <p>
              В этой главе были изучены методы управления памятью, используемые в ядре Linux. Мы рассмотрели различные единицы и категории памяти, включая байты страницы и зоны. Четыре категории адресного пространства процесса будут рассмотрены в главе 15, “Адресное пространство процесса”. Далее были рассмотрены различные механизмы выделения памяти, включая распределение на уровне блоков и страниц. Получение памяти внутри ядра связано с дополнительными трудностями, поскольку при этом приходится учитывать текущее состояние процесса, например невозможность его перехода в состояние ожидания или обращение к файловой системе. В связи с этим были рассмотрены флаги gfp, различные случаи и необходимые условия для использования каждого флага. Относительная трудность в выделении участка памяти в ядре связана с кардинально другим подходом к проектированию по сравнению с пользовательскими приложениями. Хотя большая часть этой главы посвящена описанию интерфейсов распределения памяти в ядре, вы не должны забывать и о тех трудностях, которые с этим связаны. Взяв на вооружение материал данной главы, можете смело приступать к изучению материала следующей главы, посвященного виртуальной файловой системе (virtual filesystem, VFS). Речь пойдет о подсистеме ядра, которая управляет файловыми системами и обеспечивает для пользовательских приложений единообразный и логичный интерфейс API. Вперед!   </p>
        </div>

        <div class="chapter" id="chapter14">
            <h3>Глава 13.Виртуальная файловая система</h3>
            <p>
              В операционной системе Linux поддерживается большой набор файловых систем, от “родных” ext3 и ext4 до сетевых файловых систем, таких как NFS или Coda. Сейчас в официальном ядре ОС Linux поддерживается более 60 файловых систем. Благодаря уровню VFS для всех разнообразных файловых систем создается общая база для их реализации и общий интерфейс для работы со стандартными системными функциями. Таким образом, уровень виртуальной файловой системы позволяет совершенно ясно реализовывать поддержку новых файловых систем в операционной системе Linux, а также дает возможность работать с этими файловыми системами с помощью вызовов стандартных системных функций Unix. В этой главе было описано назначение подсистемы VFS и рассмотрены соответствующие структуры данных, включая такие важные объекты, как файловый индекс (inode), элемент каталога (dentry) и суперблок. В главе 14, “Уровень блочного ввода-вывода”, речь пойдет о физической организации данных файловых систем.  </p>
        </div>

        <div class="chapter" id="chapter15">
            <h3>Глава 14. Уровень блочного ввода-вывода</h3>
            <p>
                В этой главе были рассмотрены принципы работы блочных устройств ввода-вывода, а также структуры данных, используемые на уровне блочного ввода-вывода. Вы ознакомились со структурой bio, представляющей активную (т.е. выполняемую) в данный момент операцию ввода-вывода; со структурой buffer_head, представляющей отображение блоков на страницы памяти; и со структурой request, которая представляет собой отдельный запрос ввода-вывода. После запросов ввода-вывода был описан их короткий, но важный путь, кульминацией которого является прохождение через планировщик ввода-вывода. Были рассмотрены основные противоречия, возникающие при планировании операций ввода-вывода, а также четыре типа планировщиков, которые на данный момент существуют в ядре Linux. Кроме того, мы описали также старый планировщик ввода-вывода из ядра 2.4, называемый лифтом имени Линуса. В следующей главе речь пойдет об адресном пространстве процесса.   </p>
        </div>

        <div class="chapter" id="chapter16">
            <h3>Глава 15.Адресное пространство процесса</h3>
            <p>
                В этой чрезвычайно переполненной новой информацией главе мы рассмотрели абстракцию виртуальной памяти, которая выделяется каждому процессу. Было описано, как в ядре представляются адресное пространство процесса (с помощью структуры mm_ struct) и области виртуальной памяти в этом пространстве (с помощью структуры vm_area_struct). Кроме того, вы ознакомились с процессом создания (с помощью функции mmap()) и удаления (с помощью функции munmap()) этих областей памяти. В конце главы были рассмотрены таблицы страниц. Поскольку Linux является операционной системой с поддержкой виртуальной памяти, то все эти понятия очень важны для понимания работы системы и используемой модели процессов. В следующей главе будет рассмотрен страничный кеш — универсальный кеш данных в памяти, который используется для выполнения страничных операций ввода-вывода. Кроме того, вы узнаете о том, как в ядре выполняется отложенная запись данных из измененных страниц.    </p>
        </div>

        <div class="chapter" id="chapter17">
            <h3>Глава 16. Страничный кеш и отложенная запись страниц</h3>
            <p>
               В этой главе был рассмотрен страничный кеш системы Linux и его механизм отложенной записи. Было показано, что все операции страничного ввода-вывода в ядре сначала проходят через страничных кеш. Мы увидели, как этот кеш (за счет сохранения данных в оперативной памяти компьютера) позволяет существенно увеличить общую производительность системы и уменьшить число операций ввода-вывода, выполняемых с дисками. Мы обсудили также процесс записи данных программами в страничный кеш и их последующую запись на диск с помощью механизма отложенной записи. Было показано, что при выполнении функций записи в приложении данные не записываются на диск сразу, а сначала попадают в страничный кеш, и содержащие их страницы помечаются как измененные. Далее через определенные интервалы времени активизируется группа потоков синхронизатора, которые и выполнят отложенную запись на диск. На основании материала последних нескольких глав вы получили устойчивое представление о том, как выполняется управление памятью и файловыми системами. Теперь мы плавно перейдем к теме драйверов устройств и модулей и посмотрим, как в ядре Linux обеспечивается модульная и динамическая инфраструктура, позволяющая загрузить и выгрузить код ядра прямо во время работы системы. </p>
        </div>

        <div class="chapter" id="chapter18">
            <h3>Глава 17. Устройства и модули</h3>
            <p>
                В данной главе были рассмотрены функциональные возможности ядра, которые используются для реализации драйверов устройств и поддержки их иерархии в виде древовидной структуры. Были описаны модули, объекты ядра kobject и связанные с ними множества kset и типы ktype, а также файловая система sysfs. Приведенные сведения очень важны для разработчиков драйверов устройств, поскольку они позволяют писать модульный, компактный и мощный код. В последних трех главах мы уйдем от рассмотрения специфичных для ядра Linux подсистем и остановимся на общих вопросах, связанных с ошибками ядра. В следующей главе речь пойдет о процессе отладки ядра Linux. </p>
        </div>

        <div class="chapter" id="chapter19">
            <h3>Глава 18. Отладка</h3>
            <p>
                В этой главе были рассмотрены способы отладки ядра Linux — процесса, позволяющего определить, почему всегда наши намерения расходятся с их реализацией. Мы ознакомились с несколькими методиками, включая встроенную в ядро инфраструктуру поддержки отладчиков, отладочный вывод сообщений и поиск методом половинного деления с помощью git. Поскольку отлаживать ядро Linux может быть значительно труднее, чем пользовательское приложение, материал данной главы является ключевым для всех, кто собирается писать реальный код ядра. В следующей главе будет рассмотрена еще одна важная тема, посвященная переносимости ядра Linux. Так что, вперед!  </p>
        </div>

        <div class="chapter" id="chapter20">
            <h3>Глава 19. Переносимость</h3>
            <p>
            Если говорить коротко, то написание переносимого, ясного и красивого кода для ядра Linux подразумевает два момента.

              Код необходимо разрабатывать с учетом самого общего сценария: следует предполагать, что все, что может случиться, обязательно случится, и принять на этот счет все возможные меры.

              Всегда необходимо все подводить под наименьший общий знаменатель: нельзя полагаться на то, что будут доступны все возможности ядра, следует опираться только на минимум возможностей, которые доступны на всех аппаратных платформах.

            Написание переносимого кода требует строгого учета многих факторов, в частности, размера машинного слова, размеров типов данных, выравнивания в памяти и добавления пустых полей, порядка следования байтов, знаковых и беззнаковых целых чисел, размера страницы, а также изменения порядка выполнения команд чтения/записи процессором. В большинстве случаев при создании кода ядра следует убедиться, что все типы данных используются правильно. Тем не менее время от времени все равно всплывают проблемы, связанные с особенностями той или иной аппаратной платформы. Поэтому важно понимать эти проблемы и всегда писать четкий и переносимый код ядра.</p>
        </div>

        <div class="chapter" id="chapter21">
            <h3>Глава 20. Заплаты, хакерство и сообщество</h3>
            <p>
               Наиболее важными качествами любого хакера являются желание и умение работать — вы должны сами отыскивать проблемы и решать их. В этой книге описаны основные части ядра, рассказано об интерфейсах, структурах данных, алгоритмах и принципах их работы. В книге ядро Linux описано в практической форме с точки зрения разработчика. Она предназначена для того, чтобы удовлетворить ваше любопытство и стать отправной точкой в разработке ядра. Тем не менее, как уже было сказано ранее, не существует другого способа начать разработку кода ядра, не ознакомившись с существующим кодом и не начав писать собственный код. Операционная система Linux предоставляет возможность работать в сообществе, которое не только позволяет это делать, но и активно побуждает к указанным действиям. Если есть желание действовать — вперед! Удачи в хакинге!    </p>
        </div>

        <div class="chapter" id="chapter22">
            <h3>Список литературы</h3>
             <h3>Книги по основам построения операционных систем</h3>
            <p>
            В приведенных ниже книгах рассмотрены принципы работы операционных систем в объеме учебных курсов. В них описываются основные понятия, алгоритмы и проблемы, связанные с построением высоко функциональных операционных систем, а также решения указанных проблем. Все эти книги могут быть рекомендованы, но если нужно выделить одну, то это, конечно же, книга Х.М. Дейтеля.

            Deitel H., Deitel P. and D. Choffnes. Operating Systems. Prentice Hall, 2003. Прекрасная книга по теории операционных систем с отличными примерами из теории и практики.

            Tanenbaum Andrew. Modern Operating Systems. Prentice Hall, 2007. Детальный обзор стандартных проблем разработки операционных систем, а также обсуждение многих концепций, которые используются в современных операционных системах, таких как UNIX и Windows.

            Tanenbaum Andrew. Operating Systems: Design and Implementation. Prentice Hall, 2006. Хорошие начальные сведения об основах построения, принципах работы и реализации Unix-подобной операционной системы Minix.

            Silberschatz A., Galvin P. and G. Gagne. Operating System Concepts. John Wiley and Sons, 2008. Также известна как “книга динозавра”, в связи с тем что на обложке нарисованы динозавры, которые не имеют никакого отношения к теме. Хорошее введение в основы построения операционных систем. Книга часто перерабатывается, но все издания должны быть хорошими. </p>
            <h3>Книги о ядре Unix</h3>
           <p>
           В приведенных ниже книгах описываются принципы работы и особенности реализации ядер Unix. В первых пяти рассмотрены конкретные варианты Unix, в двух последних — общие моменты всех вариантов Unix. Если собираетесь приобрести только две из перечисленных ниже книг, остановите свой выбор на двух последних.

     Bach Maurice. The Design of the Unix Operating System. Prentice Hall, 1986. Обсуждение особенностей построения операционной системы Unix System V, Release 2.

     McKusick M., Bostic K., Karels M. and J. Quarterman. The Design and Implementation of the 4.4BSD Operating System. Addison-Wesley, 1996. Описание особенностей построения и реализации операционной системы 4.4BSD от разработчиков этой системы.

     McKusick M. and G. Neville-Neil. The Design and Implementation of the FreeBSD Operating System. Addison-Wesley, 2004. Описаны основы построения и реализации операционной системы FreeBSD 5.2.

     McDougall R. and J. Mauro. Solaris Internals: Solaris and OpenSolaris Kernel Architecture. Prentice Hall, 2006. Интересное обсуждение основных подсистем и алгоритмов работы ядра ОС Solaris.

     Cooper C. and C. Moore. HP-UX 11i Internals. Prentice Hall, 2004. Обзор внутреннего устройства операционной системы HP-UX и аппаратной платформы PA-RISC.

     Vahalia, Uresh. Unix Internals: The New Frontiers. Prentice Hall, 1995. Отличная книга о возможностях современных Unix-подобных операционных систем, включая управление потоками и мультипрограммным режимом работы ядра.

     Schimmel Curt. UNIX Systems for Modern Architectures: Symmetric Multiprocessing and Caching for Kernel Programmers. Addison-Wesley, 1994. Прекрасная книга о проблемах поддержки современных аппаратных платформ современными Unix-подобными операционными системами. Настоятельно рекомендуется к прочтению!

     ​ </p>
           <h3>Книги о ядре Linux</h3>
          <p>
          В этих книгах, как и в текущей, рассказывается о ядрах Linux. В этом разделе пока что не так много книг. Тем не менее я настоятельно рекомендую прочитать две книги, которые указаны здесь.

          Benvenuti, Christian. Understanding Linux Network Internals. O’Reilly and Associates, 2005. Подробное описание сетевой подсистемы Linux.

          Corbet, J.,A. Rubini, and G. Kroah-Hartman. Linux Device Drivers. O’Reilly and Associates, 2005. Великолепное описание способов создания драйверов устройств для ядра Linux серии 2.6. Особый акцент сделан на программных интерфейсах, поддерживающих различные типы устройств.     </p>
          <h3>Книги о ядрах других операционных систем</h3>
         <p>
         Всегда полезно понимать логику работы конкурентов. В приведенных здесь книгах описаны основы работы и особенности реализации операционных систем, отличных от операционной системы Linux. Смотрите сами, что у них хорошо, а что — плохо.

   Kogan M. and H. Deitel. The Design of OS/2. Addison-Wesley, 1996. Интересный обзор операционной системы OS/2 2.0.

   Singh, Amit. Mac OS X Internals: A Systems Approach. Addison-Wesley Professional, 2006. Глубокий и всеобъемлющий трактат обо всех особенностях реализации Mac OS X.

   Solomon D. and M. Russinovich. Windows Internals: Covering Windows Server 2008 and Windows Vista. Microsoft Press, 2009. Интересный взгляд на операционные системы, которые отличаются от Unix.</p>
         <h3>Книги по API Unix</h3>
        <p>
        Детальное описание системы Unix и API этой операционной системы важно не только для того, чтобы писать многофункциональные прикладные программы, но и для понимания того, какие функции выполняет ядро.

   Love, Robert. Linux System Programming. O’Reilly and Associates, 2007. Книга вашего покорного слуги, в которой рассматривается создание программ для ОС Linux на системном уровне, а также описываются системные функции и API библиотеки libc. Особое внимание уделяется специфичным для Linux особенностям программирования.

   Stevens, W.R. and S. Rago. Advanced Programming in the UNIX Environment. Addison-Wesley, 2008. Отличное, если не самое полное, описание интерфейса системных функций Unix.

   3. Stevens W. Richard. UNIX Network Programming, Volume 1. Prentice Hall, 2004. Классический учебник по API сокетов операционной системы Unix.     </p>
        <h3>Книги по программированию на языке C</h3>
       <p>
       Как и большинство других программ для ОС Unix, ядро Linux написано на языке C. В двух перечисленных ниже книгах язык C описан очень подробно.

   Брайан У. Керниган, Деннис М. Ритчи. Язык программирования C, 2-е издание, ISBN 978-5-8459-0891-9. Пер. с англ., ИД “Вильямс”, 2012. Самая авторитетная книга по языку C, написанная самим автором этого языка и его коллегой.

   van der Linden, Peter. Expert C Programming. Prentice Hall, 1994. Очень подробное описание некоторых непонятных моментов программирования на языке C. У автора этой книги отличное чувство юмора.      </p>
       <h3>Другие работы</h3>
      <p>
      Ниже приведена подборка других книг, прямо не связанных с технологией разработки операционных систем, однако в них обсуждаются темы, которые, без сомнения, будут вам интересны.

  Hofstadter, Douglas. Gцdel, Escher, Bach: An Eternal Golden Braid. Basic Books, 1999. Глубокий и беспристрастный взгляд на проблемы человечества сквозь призму исследований различных предметов, включая кибернетику. Ниже приведена подборка других книг, прямо не связанных с технологией разработки операционных систем, однако в них обсуждаются темы, которые, без сомнения, будут вам интересны. 1. Hofstadter, Douglas. Gцdel, Escher, Bach: An Eternal Golden Braid. Basic Books, 1999. Глубокий и беспристрастный взгляд на проблемы человечества сквозь призму исследований различных предметов, включая кибернетику.

  Дональд Э. Кнут. Искусство программирования, том 1. Основные алгоритмы, 3-е издание. ISBN 978-5-8459-0080-7. Пер. с англ. ИД “Вильямс”, 2000. Бесценный том, посвященный основным алгоритмам информатики, включая алгоритмы управления памятью, используемые в ядре.    </p>
      <h3>Веб сайты</h3>
     <p>
     Kernel.org. Официальное хранилище исходного кода ядра Linux. Кроме того, здесь же хранится большое количество заплат ядра, сделанных разработчиками. http://www.kernel.org.

     Linux Weekly News. Великолепный новостной сайт, посвященный толковым и подробным комментариям, посвященным недельным новостям, произошедшим в мире Linux, включая ядро. Настоятельно рекомендуется! http://www.lwn.net.

     OS News. Новости в мире операционных систем, включая свежие статьи, интервью и обзоры. http://www.osnews.com.  </p>
        </div>



    </div>




</body>
</html>

